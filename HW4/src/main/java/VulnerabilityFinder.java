import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.callgraph.propagation.PointerAnalysis;
import com.ibm.wala.ipa.callgraph.propagation.SSAPropagationCallGraphBuilder;
import com.ibm.wala.ipa.cha.ClassHierarchyFactory;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ipa.slicer.NormalStatement;
import com.ibm.wala.ipa.slicer.SDG;
import com.ibm.wala.ipa.slicer.Slicer;
import com.ibm.wala.ipa.slicer.Statement;
import com.ibm.wala.ssa.SSAAbstractInvokeInstruction;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.types.*;
import com.ibm.wala.util.collections.HashSetFactory;
import com.ibm.wala.util.config.AnalysisScopeReader;
import com.ibm.wala.util.graph.traverse.BFSPathFinder;
import com.ibm.wala.util.io.FileProvider;
import com.ibm.wala.util.strings.Atom;

import java.io.File;
import java.io.PrintStream;
import java.net.URL;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static com.ibm.wala.types.TypeReference.findOrCreate;


public class VulnerabilityFinder {


    public static void main(String[] args) throws Exception {

        File exFile = new FileProvider().getFile("Java60RegressionExclusions.txt");

        URL resource = VulnerabilityFinder.class.getResource("Sample.jar");

        String runtimeClasses = VulnerabilityFinder.class.getResource("jdk-17.0.1/rt.jar").getPath();


        AnalysisScope scope = AnalysisScopeReader.makeJavaBinaryAnalysisScope(resource.getPath(), exFile);

        AnalysisScopeReader.addClassPathToScope(runtimeClasses, scope, ClassLoaderReference.Primordial);

        IClassHierarchy classHierarchy = ClassHierarchyFactory.make(scope);

        int numClasses = classHierarchy.getNumberOfClasses();

        System.out.print("Primordial classes: ");

        System.out.println(numClasses);


        numClasses = 0;

        for (IClass iClass : classHierarchy) {

            if (iClass.getClassLoader().getReference().equals(ClassLoaderReference.Application))

                numClasses = numClasses + 1;

        }

        System.out.print("Application classes: ");

        System.out.println(numClasses);


        AnalysisOptions options = new AnalysisOptions();

        options.setEntrypoints(Util.makeMainEntrypoints(scope, classHierarchy));

        SSAPropagationCallGraphBuilder builder = Util.makeNCFABuilder(2, options, new AnalysisCacheImpl(), classHierarchy, scope);

        CallGraph callGraph = builder.makeCallGraph(options);


        System.out.println("Nodes: " + callGraph.getNumberOfNodes());

        int numEdges = 0;

        for (CGNode cgNode : callGraph) {

            numEdges = numEdges + callGraph.getSuccNodeCount(cgNode);

        }

        System.out.println("Edges: " + numEdges);


        PointerAnalysis<InstanceKey> pa = builder.getPointerAnalysis();


        SDG<InstanceKey> sdg = new SDG(callGraph, pa, Slicer.DataDependenceOptions.NO_BASE_NO_HEAP_NO_EXCEPTIONS,

                Slicer.ControlDependenceOptions.NO_EXCEPTIONAL_EDGES);

        Set<Statement> sources = findSources(sdg);

        Set<Statement> sinks = findSinks(sdg);

        Set<List<Statement>> vulnerablePaths = getVulnerablePaths(sdg, sources, sinks);


        // Write paths to file output.txt

        File file = new File("output.txt");

        PrintStream stream = new PrintStream(file);

        System.setOut(stream);


        for (List<Statement> path : vulnerablePaths) {

            System.out.println("VULNERABLE PATH");

            for (Statement statement : path) {

                System.out.println("\t" + statement);

            }

            System.out.println("~~~~~~~~~~");

        }

    }


    private static boolean isApplicationScope(IClass declaringClass) {

        return declaringClass.getClassLoader().getReference().equals(ClassLoaderReference.Application);

    }


    public static Set<Statement> findSources(SDG<InstanceKey> sdg) {

        Set<Statement> result = new HashSet<>();

        for (Statement s : sdg) {

            if (s.getKind().equals(Statement.Kind.NORMAL) && isApplicationScope(s.getNode().getMethod().getDeclaringClass())) {

                SSAInstruction instruction = ((NormalStatement) s).getInstruction();

                if ((instruction.toString().contains("readLine") && (instruction instanceof SSAAbstractInvokeInstruction))) {

                    result.add(s);

                }

            }

        }

        return result;

    }


    public static Set<Statement> findSinks(SDG<InstanceKey> sdg) {

        TypeReference JavaLangRuntime =

                findOrCreate(ClassLoaderReference.Application, TypeName.string2TypeName("Ljava/lang/Runtime"));

        MethodReference sinkReference =

                MethodReference.findOrCreate(JavaLangRuntime,

                        Atom.findOrCreateUnicodeAtom("exec"),

                        Descriptor.findOrCreateUTF8("(Ljava/lang/String;)Ljava/lang/Process;"));


        Set<Statement> result = new HashSet<>();

        for (Statement s : sdg) {

            if (s.getKind().equals(Statement.Kind.NORMAL) && isApplicationScope(s.getNode().getMethod().getDeclaringClass())) {

                SSAInstruction instruction = ((NormalStatement) s).getInstruction();

                if (instruction instanceof SSAAbstractInvokeInstruction) {

                    if (((SSAAbstractInvokeInstruction) instruction).getDeclaredTarget().equals(sinkReference))

                        result.add(s);

                }

            }

        }

        return result;

    }


    public static Set<List<Statement>> getVulnerablePaths(SDG<? extends InstanceKey> G, Set<Statement> sources, Set<Statement> sinks) {

        Set<List<Statement>> result = HashSetFactory.make();

        for (Statement src : G) {

            if (sources.contains(src)) {

                for (Statement dst : G) {

                    if (sinks.contains(dst)) {

                        BFSPathFinder<Statement> paths = new BFSPathFinder<>(G, src, dst);

                        List<Statement> path = paths.find();

                        if (path != null) {

                            result.add(path);

                        }

                    }

                }

            }

        }

        return result;

    }


}


